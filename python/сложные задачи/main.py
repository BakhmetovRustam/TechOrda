# переменная ##sum-1-n  Дается число n. Вернуть сумму от 1 до n без использования циклов.
# Ограничения 1 <= n <= 65535 Sample Input: 5 Sample Output: 15
def sum_1_to_n(n):
    return n * (n + 1) // 2


##count-leap-year  В этой задаче вам нужно вернуть кол-во високосных лет до заданного n года.
# Правило для определения високосного года [источник]: год, номер которого кратен 400, — високосный;
# остальные годы, номер которых кратен 100, — невисокосные (например, годы 1700, 1800, 1900, 2100, 2200, 2300);
# остальные годы, номер которых кратен 4, — високосные. все остальные годы — невисокосные.
# Допускается, что високосные годы можно считать с 0 года. Пример До года 100 присутстует 24 високосных лет.
# Ограничения n > 0 Запрещенные библиотеки, конструкции for Sample Input: 4 Sample Output: 1
def count_leap_years(n):
    leap_years = (n // 4) - (n // 100) + (n // 400)
    return leap_years


##swap-bits  Реализуйте метод, который меняет местами первые 4 бита с остальными 4 и возвращает результат.
# Примеры 0000 1111 -> 1111 0000 0110 0111 -> 0111 0110 Ограничения 0 <= a <= 255 Sample Input: 15 Sample Output: 240
def swap_bits(a):
    return ((a & 0x0F) << 4) | (a >> 4)


##sort-nums-three  Напишите функцию, которая отсортировывает по возрастанию три числа a, b, c, без использования циклов.
# Отсортированные числа вывести в консоль. Пример 3 2 1 -> 1 2 3 Sample Input: 3 2 1 Sample Output: 1 2 3
def sort_three_nums(a, b, c):
    if a > b:
        a, b = b, a
    if b > c:
        b, c = c, b
    if a > b:
        a, b = b, a
    print(a, b, c)


##median  Реализовать функцию median, которое находится в середине массива, если его упорядочить по возрастанию,
# то есть такое число, что половина из элементов набора не меньше него, а другая половина не больше.
# Если кол-во элементов в массиве четное, то нужно вернуть левое значение медианы.
# Ограничения 0 <= array.length <= 10_000 Sample Input: [1, 2, 3] Sample Output: 2
def median(arr):
    arr.sort()
    return arr[(len(arr) - 1) // 2]


##miss-you  Дается два массива чисел, вернуть числа из второго массива, которые не присутствуют в первом в отсортированном порядке.
# Ограничения 0 <= array1.length <= 10_000 0 <= array2.length <= 10_000
# Sample Input: [1, 1, 3, 2, 5] [1, 3, 9, 1, 5, 7] Sample Output: [7, 9]
def missing_numbers(arr1, arr2):
    set1 = set(arr1)
    return sorted([x for x in arr2 if x not in set1])


##perfectly-balanced  Дается массив чисел, найти в массиве такой элемент, где сумма чисел слева равна сумме чисел справа.
# Если такое число есть, то вернуть true, в противном случае false.
# Пример Возьмем массив 1, 2, 9, 8, 5, 7 Число 8 является элементом, где сумма чисел слева равна сумме чисел справа. 1 2 9 8 5 7
#(1+2+9)=12 ↑ (5+7)=12 Ограничения 0 <= array.length <= 10_000 Sample Input: [1, 2, 9, 8, 5, 7] Sample Output: true
def perfectly_balanced(arr):
    total_sum = sum(arr)
    left_sum = 0
    for i, num in enumerate(arr):
        total_sum -= num
        if left_sum == total_sum:
            return True
        left_sum += num
    return False


##stock-buy  Два друга хотят скинуться, чтобы купить акции на Jusan Invest.
# Им нужно купить две акции на всю сумму, которая у них есть. Дается доступная сумма денег m и список цен на различные акции s.
# Напечатайте индексы акции, которые можно купить. Напечатанные индексы должны быть отсортированы по возрастанию.
# Предполагается, что такие числа всегда существуют в списке цен акции s, сумма которых равна m.
# Пример m = 8, s = [8 7 3 1 3 10] Правильный ответ 1 3 Число по индексу [1] это 7, а по индексу [3] это 1.
# Соответственно, 7 + 1 = 8. Ограничения m > 1 2 <= array.length <= 10_000 Sample Input: 3 [1, 2, 3] Sample Output: 0 1
def stock_buy(m, prices):
    for i in range(len(prices)):
        for j in range(i + 1, len(prices)):
            if prices[i] + prices[j] == m:
                return sorted([i, j])


# Самая сложная задача фукнции ##hanoi-tower  "Ханойские башни" - это математическая головоломка. Паззл состоит из
# трех башен и нескольких дисков (бубликов). Задача состоит в том, что нужно переместить диски из первой башни в
# последнюю. При этом, диски меньшего размера можно положить сверху большего, но не наоборот. Напишите функцию
# hanoiTower, которая принимает число дисков n. Диски расположены на первой башне в порядке возрастания (снизу диски
# с большим значением, сверху наименьшим). Функция должна напечатать последовательность перекладываний в формате:
# Диск a с башни b переложить в башню c где, а номер диска b номер башни, с которой снимают диск c номер башни,
# на которую ложат диск Функция должна вывести минимальное количество команд для перемещения дисков с первой башни на
# последнюю. Пример Пример вывода программы для n = 2 Диск 1 с башни 1 переложить в башню 2 Диск 2 с башни 1
# переложить в башню 3 Диск 1 с башни 2 переложить в башню 3 Ограничения 0 < n < 100 Sample Input: 5 Sample Output:
# Диск 1 с башни 1 переложить в башню 3 Диск 2 с башни 1 переложить в башню 2 Диск 1 с башни 3 переложить в башню 2
# Диск 3 с башни 1 переложить в башню 3 Диск 1 с башни 2 переложить в башню 1 Диск 2 с башни 2 переложить в башню 3
# Диск 1 с башни 1 переложить в башню 3 Диск 4 с башни 1 переложить в башню 2 Диск 1 с башни 3 переложить в башню 2
# Диск 2 с башни 3 переложить в башню 1 Диск 1 с башни 2 переложить в башню 1 Диск 3 с башни 3 переложить в башню 2
# Диск 1 с башни 1 переложить в башню 3 Диск 2 с башни 1 переложить в башню 2 Диск 1 с башни 3 переложить в башню 2
# Диск 5 с башни 1 переложить в башню 3 Диск 1 с башни 2 переложить в башню 1 Диск 2 с башни 2 переложить в башню 3
# Диск 1 с башни 1 переложить в башню 3 Диск 3 с башни 2 переложить в башню 1 Диск 1 с башни 3 переложить в башню 2
# Диск 2 с башни 3 переложить в башню 1 Диск 1 с башни 2 переложить в башню 1 Диск 4 с башни 2 переложить в башню 3
# Диск 1 с башни 1 переложить в башню 3 Диск 2 с башни 1 переложить в башню 2 Диск 1 с башни 3 переложить в башню 2
# Диск 3 с башни 1 переложить в башню 3 Диск 1 с башни 2 переложить в башню 1 Диск 2 с башни 2 переложить в башню 3
# Диск 1 с башни 1 переложить в башню 3

def hanoi_tower(n, start=1, target=3, auxiliary=2):
    if n == 1:
        print(f"Диск {n} с башни {start} переложить в башню {target}")
        return
    # Перемещаем n-1 дисков на вспомогательную башню
    hanoi_tower(n - 1, start, auxiliary, target)

    # Перемещаем самый большой диск на целевую башню
    print(f"Диск {n} с башни {start} переложить в башню {target}")

    # Перемещаем n-1 дисков со вспомогательной башни на целевую
    hanoi_tower(n - 1, auxiliary, target, start)




if __name__ == '__main__':
    print(sum_1_to_n(5))
    print(count_leap_years(4))
    print(swap_bits(15))
    print(sort_three_nums(3, 2, 1))
    print(median([1, 2, 3]))
    print(missing_numbers([1, 1, 3, 2, 5], [1, 3, 9, 1, 5, 7]))
    print(perfectly_balanced([1, 2, 9, 8, 5, 7]))
    print(stock_buy(3, [1, 2, 3]))
    print(hanoi_tower(5))
